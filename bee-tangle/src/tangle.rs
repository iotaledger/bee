// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

use crate::{vertex::Vertex, MessageRef};

use bee_message::{Message, MessageId};

use async_trait::async_trait;
// use dashmap::{mapref::entry::Entry, DashMap};
use hashbrown::{
    hash_map::{DefaultHashBuilder, Entry},
    HashMap, HashSet,
};
use log::info;
use lru::LruCache;
use tokio::sync::{RwLock as TRwLock, RwLockReadGuard as TRwLockReadGuard, mpsc};

use std::{
    fmt::Debug,
    marker::PhantomData,
    ops::Deref,
    future::Future,
    sync::Arc,
};

pub const DEFAULT_CACHE_LEN: usize = 100_000;

/// A trait used to provide hooks for a tangle. The tangle acts as an in-memory cache and will use hooks to extend its
/// effective volume. When an entry doesn't exist in the tangle cache and needs fetching, or when an entry gets
/// inserted, the tangle will call out to the hooks in order to fulfil these actions.
#[async_trait]
pub trait Hooks<T> {
    /// An error generated by these hooks.
    type Error: Debug;

    /// Fetch a message from some external storage medium.
    async fn get(&self, message_id: &MessageId) -> Result<Option<(Message, T)>, Self::Error>;
    /// Insert a message into some external storage medium.
    async fn insert(&self, message_id: MessageId, tx: Message, metadata: T) -> Result<(), Self::Error>;
    /// Fetch the approvers list for a given message.
    async fn fetch_approvers(&self, message_id: &MessageId) -> Result<Option<Vec<MessageId>>, Self::Error>;
    /// Insert a new approver for a given message.
    async fn insert_approver(&self, message_id: MessageId, approver: MessageId) -> Result<(), Self::Error>;
    /// Update the approvers list for a given message.
    async fn update_approvers(&self, message_id: MessageId, approvers: &Vec<MessageId>) -> Result<(), Self::Error>;
}

/// Phoney default hooks that do nothing.
pub struct NullHooks<T>(PhantomData<T>);

impl<T> Default for NullHooks<T> {
    fn default() -> Self {
        Self(PhantomData)
    }
}

#[async_trait]
impl<T: Send + Sync> Hooks<T> for NullHooks<T> {
    type Error = ();

    async fn get(&self, _message_id: &MessageId) -> Result<Option<(Message, T)>, Self::Error> {
        Ok(None)
    }

    async fn insert(&self, _message_id: MessageId, _tx: Message, _metadata: T) -> Result<(), Self::Error> {
        Ok(())
    }

    async fn fetch_approvers(&self, _message_id: &MessageId) -> Result<Option<Vec<MessageId>>, Self::Error> {
        Ok(None)
    }

    async fn insert_approver(&self, _message_id: MessageId, _approver: MessageId) -> Result<(), Self::Error> {
        Ok(())
    }

    async fn update_approvers(&self, _message_id: MessageId, _approvers: &Vec<MessageId>) -> Result<(), Self::Error> {
        Ok(())
    }
}

#[derive(Debug)]
pub enum Event {
    Resize(usize),
    Access(MessageId),
    Insert(MessageId),
}

/// A foundational, thread-safe graph datastructure to represent the IOTA Tangle.
pub struct Tangle<T, H = NullHooks<T>>
where
    T: Clone,
{
    // Global Tangle Lock. Remove this as and when it is deemed correct to do so.
    vertices: TRwLock<HashMap<MessageId, Vertex<T>>>,
    children: TRwLock<HashMap<MessageId, (HashSet<MessageId>, bool)>>,

    pub(crate) hooks: H,

    events_tx: mpsc::UnboundedSender<Event>,
}

// impl<T, H: Hooks<T>> Default for Tangle<T, H>
// where
//     T: Clone,
//     H: Default,
// {
//     fn default() -> Self {
//         Self::new(H::default())
//     }
// }

impl<T, H: Hooks<T>> Tangle<T, H>
where
    T: Clone,
{
    /// Creates a new Tangle.
    pub fn new(hooks: H) -> (Arc<Self>, impl Future<Output = ()>) {
        let (events_tx, mut events_rx) = mpsc::unbounded_channel();

        let this = Arc::new(Self {
            vertices: TRwLock::new(HashMap::new()),
            children: TRwLock::new(HashMap::new()),

            hooks,

            events_tx,
        });

        let evicter = {
            let tangle = this.clone();
            async move {
                let mut lru = LruCache::with_hasher(usize::MAX, DefaultHashBuilder::default());
                let mut cache_len = DEFAULT_CACHE_LEN;

                while let Some(event) = events_rx.recv().await {
                    let needs_eviction = match event {
                        Event::Resize(len) => { cache_len = len; true },
                        Event::Access(message_id) => { lru.put(message_id, ()); false },
                        Event::Insert(message_id) => { lru.put(message_id, ()); true },
                    };

                    if needs_eviction {
                        // Perform eviction of excess cache entries
                        let mut vertices = tangle.vertices.write().await;
                        let mut children = tangle.children.write().await;
                        while vertices.len() > cache_len {
                            let remove = lru.pop_lru().map(|(id, _)| id);

                            if let Some(message_id) = remove {
                                vertices.remove(&message_id);
                                children.remove(&message_id);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
        };

        (this, evicter)
    }

    /// Change the maximum number of entries to store in the cache.
    pub fn resize(&self, len: usize) {
        self.events_tx.send(Event::Resize(len)).unwrap();
    }

    /// Create a new tangle with the given capacity.
    // pub fn with_capacity(self, cap: usize) -> Self {
    //     Self {
    //         cache_queue: Mutex::new(LruCache::with_hasher(cap + 1, DefaultHashBuilder::default())),
    //         ..self
    //     }
    // }

    /// Return a reference to the storage hooks used by this tangle.
    pub fn hooks(&self) -> &H {
        &self.hooks
    }

    async fn insert_inner(&self, message_id: MessageId, message: Message, metadata: T) -> Option<MessageRef> {
        match self.vertices.write().await.entry(message_id) {
            Entry::Occupied(_) => None,
            Entry::Vacant(entry) => {
                for parent in message.parents().iter() {
                    self.add_child_inner(*parent, message_id).await;
                }
                let vtx = Vertex::new(message, metadata);
                let tx = vtx.message().clone();
                entry.insert(vtx);

                self.events_tx.send(Event::Insert(message_id)).unwrap();

                Some(tx)
            }
        }
    }

    /// Inserts a message, and returns a thread-safe reference to it in case it didn't already exist.
    pub async fn insert(&self, message_id: MessageId, message: Message, metadata: T) -> Option<MessageRef> {
        if self.contains_inner(&message_id).await {
            None
        } else {
            // Insert into backend using hooks
            self.hooks
                .insert(message_id, message.clone(), metadata.clone())
                .await
                .unwrap_or_else(|e| info!("Failed to insert message {:?}", e));

            self.insert_inner(message_id, message, metadata).await
        }
    }

    #[inline]
    async fn add_child_inner(&self, parent: MessageId, child: MessageId) {
        let mut children_map = self.children.write().await;
        let children = children_map
            .entry(parent)
            .or_insert_with(|| (HashSet::default(), false));
        children.0.insert(child);
        drop(children_map);
        self.hooks
            .insert_approver(parent, child)
            .await
            .unwrap_or_else(|e| info!("Failed to update approvers for message {:?}", e));
    }

    async fn get_inner(&self, message_id: &MessageId) -> Option<impl Deref<Target = Vertex<T>> + '_> {
        let res = TRwLockReadGuard::try_map(self.vertices.read().await, |m| m.get(message_id)).ok();

        if res.is_some() {
            self.events_tx.send(Event::Access(*message_id)).unwrap();
        }

        res
    }

    /// Get the data of a vertex associated with the given `message_id`.
    pub async fn get(&self, message_id: &MessageId) -> Option<MessageRef> {
        self.pull_message(message_id).await;

        self.get_inner(message_id).await.map(|v| v.message().clone())
    }

    async fn contains_inner(&self, message_id: &MessageId) -> bool {
        self.vertices.read().await.contains_key(message_id)
    }

    /// Returns whether the message is stored in the Tangle.
    pub async fn contains(&self, message_id: &MessageId) -> bool {
        self.contains_inner(message_id).await || self.pull_message(message_id).await
    }

    /// Get the metadata of a vertex associated with the given `message_id`.
    pub async fn get_metadata(&self, message_id: &MessageId) -> Option<T> {
        self.pull_message(message_id).await;

        self.get_metadata_maybe(message_id).await
    }

    /// Get the metadata of a vertex associated with the given `message_id`, if it's in the cahce.
    pub async fn get_metadata_maybe(&self, message_id: &MessageId) -> Option<T> {
        self.get_inner(message_id).await.map(|v| v.metadata().clone())
    }

    /// Get the metadata of a vertex associated with the given `message_id`.
    pub async fn get_vertex(&self, message_id: &MessageId) -> Option<impl Deref<Target = Vertex<T>> + '_> {
        self.pull_message(message_id).await;

        self.get_inner(message_id).await
    }

    /// Updates the metadata of a particular vertex.
    pub async fn set_metadata(&self, message_id: &MessageId, metadata: T) {
        self.pull_message(message_id).await;
        if let Some(vtx) = self.vertices.write().await.get_mut(message_id) {
            *vtx.metadata_mut() = metadata;
            self.hooks
                .insert(*message_id, (&**vtx.message()).clone(), vtx.metadata().clone())
                .await
                .unwrap_or_else(|e| info!("Failed to update metadata for message {:?}", e));
        }
    }

    /// Updates the metadata of a vertex.
    pub async fn update_metadata<R, Update>(&self, message_id: &MessageId, mut update: Update) -> Option<R>
    where
        Update: FnMut(&mut T) -> R,
    {
        self.pull_message(message_id).await;
        if let Some(vtx) = self.vertices.write().await.get_mut(message_id) {
            let r = update(vtx.metadata_mut());
            self.hooks
                .insert(*message_id, (&**vtx.message()).clone(), vtx.metadata().clone())
                .await
                .unwrap_or_else(|e| info!("Failed to update metadata for message {:?}", e));

            Some(r)
        } else {
            None
        }
    }

    /// Returns the number of messages in the Tangle.
    pub async fn len(&self) -> usize {
        // Does not take GTL because this is effectively atomic
        self.vertices.read().await.len()
    }

    /// Checks if the tangle is empty.
    pub async fn is_empty(&self) -> bool {
        self.len().await == 0
    }

    async fn children_inner(&self, message_id: &MessageId) -> Option<impl Deref<Target = HashSet<MessageId>> + '_> {
        // struct Children<'a> {
        //     children: dashmap::mapref::one::Ref<'a, MessageId, (HashSet<MessageId>, bool)>,
        // }

        // impl<'a> Deref for Children<'a> {
        //     type Target = HashSet<MessageId>;

        //     fn deref(&self) -> &Self::Target {
        //         &self.children.deref().0
        //     }
        // }

        struct Wrapper<'a> {
            children: HashSet<MessageId>,
            phantom: PhantomData<&'a ()>,
        }

        impl<'a> Deref for Wrapper<'a> {
            type Target = HashSet<MessageId>;

            fn deref(&self) -> &Self::Target {
                &self.children
            }
        }

        let children_map = self.children.read().await;
        let children = children_map
            .get(message_id)
            // Skip approver lists that are not exhaustive
            .filter(|children| children.1);

        let children = match children {
            Some(children) => children.0.clone(),
            None => {
                drop(children_map);
                let to_insert = match self.hooks.fetch_approvers(message_id).await {
                    Err(e) => {
                        info!("Failed to update approvers for message message {:?}", e);
                        Vec::new()
                    }
                    Ok(None) => Vec::new(),
                    Ok(Some(approvers)) => approvers,
                };

                self.children
                    .write()
                    .await
                    .insert(*message_id, (to_insert.into_iter().collect(), true));

                self.children
                    .read()
                    .await
                    .get(message_id)
                    .expect("Approver list inserted and immediately evicted")
                    .0
                    .clone()
            }
        };

        self.events_tx.send(Event::Access(*message_id)).unwrap();

        Some(/* Children { children } */ Wrapper {
            children,
            phantom: PhantomData,
        })
    }

    /// Returns the children of a vertex, if we know about them.
    pub async fn get_children(&self, message_id: &MessageId) -> Option<HashSet<MessageId>> {
        // Effectively atomic
        self.children_inner(message_id).await.map(|approvers| approvers.clone())
    }

    /// Returns the number of children of a vertex.
    pub async fn num_children(&self, message_id: &MessageId) -> usize {
        // Effectively atomic
        self.children_inner(message_id)
            .await
            .map_or(0, |approvers| approvers.len())
    }

    #[cfg(test)]
    pub async fn clear(&mut self) {
        self.vertices.write().await.clear();
        self.children.write().await.clear();
    }

    // Attempts to pull the message from the storage, returns true if successful.
    async fn pull_message(&self, message_id: &MessageId) -> bool {
        // If the tangle already contains the tx, do no more work
        if self.vertices.read().await.contains_key(message_id) {
            true
        } else {
            if let Ok(Some((tx, metadata))) = self.hooks.get(message_id).await {
                self.insert_inner(*message_id, tx, metadata).await;
                true
            } else {
                false
            }
        }
    }

    // fn generate_cache_index(&self) -> u64 {
    //     self.cache_counter.fetch_add(1, Ordering::Relaxed)
    // }

    // async fn perform_eviction(&self) {
    //     let mut vertices = self.vertices.write().await;
    //     let mut children = self.children.write().await;
    //     let mut cache_queue = self.cache_queue.lock().await;
    //     while vertices.len() > cache_queue.cap() {
    //         let remove = cache_queue.pop_lru().map(|(id, _)| id);

    //         if let Some(message_id) = remove {
    //             vertices.remove(&message_id);
    //             children.remove(&message_id);
    //         } else {
    //             break;
    //         }
    //     }
    // }
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use bee_test::message::create_random_tx;
//     use pollster::block_on;
//
//     #[test]
//     fn new_tangle() {
//         let _: Tangle<u8> = Tangle::default();
//     }
//
//     #[test]
//     fn insert_and_contains() {
//         let tangle = Tangle::<()>::default();
//
//         let (message_id, tx) = create_random_tx();
//
//         let insert1 = block_on(tangle.insert(message_id, tx.clone(), ()));
//
//         assert!(insert1.is_some());
//         assert_eq!(1, tangle.len());
//         assert!(block_on(tangle.contains(&message_id)));
//
//         let insert2 = block_on(tangle.insert(message_id, tx, ()));
//
//         assert!(insert2.is_none());
//         assert_eq!(1, tangle.len());
//         assert!(block_on(tangle.contains(&message_id)));
//     }
//
//     #[test]
//     fn eviction_cap() {
//         let tangle = Tangle::<()>::default().with_capacity(5);
//
//         let txs = (0..10).map(|_| create_random_tx()).collect::<Vec<_>>();
//
//         for (message_id, tx) in txs.iter() {
//             let _ = block_on(tangle.insert(*message_id, tx.clone(), ()));
//         }
//
//         assert_eq!(tangle.len(), 5);
//     }
//
//     #[test]
//     fn eviction_update() {
//         let tangle = Tangle::<()>::default().with_capacity(5);
//
//         let txs = (0..8).map(|_| create_random_tx()).collect::<Vec<_>>();
//
//         for (message_id, tx) in txs.iter().take(4) {
//             let _ = block_on(tangle.insert(*message_id, tx.clone(), ()));
//         }
//
//         assert!(block_on(tangle.get(&txs[0].0)).is_some());
//
//         for (message_id, tx) in txs.iter().skip(4) {
//             let _ = block_on(tangle.insert(*message_id, tx.clone(), ()));
//         }
//
//         assert!(block_on(tangle.contains(&txs[0].0)));
//
//         for entry in tangle.vertices.iter() {
//             assert!(entry.key() == &txs[0].0 || txs[4..].iter().any(|(h, _)| entry.key() == h));
//         }
//     }
// }
